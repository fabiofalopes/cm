# Consumir uma API em Flutter LOTR - Parte 2

Neste vídeo vamos continuar a trabalhar nesta aplicação do Lord of the Rings. Neste momento os dados que aqui estão estão fixos. Isto foi mostrado no último vídeo. Nós agora vamos ligar isto ao servidor para passar a ter os personagens reais do Lord of the Rings.

Primeira coisa que eu quero fazer antes de ligar isto ao servidor é melhorar um bocadinho a arquitetura desta aplicação. Neste momento esta classe de repositório, eu vou só mostrar, tem os tais dados fixos. Ela é criada explicitamente, ela é instanciada explicitamente aqui no characters list page e depois também no Character detail page. E eu acho que isto não é forma correta. Nós devíamos injetar esta dependência porque se no futuro quisermos fazer testes em que não vamos ao servidor quando corremos os testes e vamos ao servidor quando corremos a aplicação real, nós vamos querer injetar uma dependência diferente em cada um dos casos. E desta forma torna-se mais complicado fazer este tipo de comportamento.

Portanto vamos começar já por usar o provider que já aprenderam noutro vídeo meu para injetar este characters repository. Aqui para injetar este characters repository, aqui para começar temos que ir aqui ao pubspec.yaml e acrescentar a dependência. Acrescentei também já aqui esta dependência do http que vamos precisar mais à frente. Não esqueça de fazer pub get.

E agora já podemos usar aqui o provider. Para isso vamos fazer Context e temos que dizer aqui qual é o objeto que queremos obter, neste caso repository. E aqui vamos precisar da mesma coisa. Aqui importar. Pronto, o que que falta ainda? Quando nós usamos o provider para isto funcionar, nós temos que no Main dizer que isto está encapsulado num provider. Temos que ter um Create. Eu agora vou simplificar isto, eu não preciso deste contexto já. Agora quando vocês não precisam do argumento que está no lambda, vocês podem simplesmente trocá-lo por um underscore. E aqui podemos usar uma expressão. E aqui o que eu quero é basicamente dizer qual é o objeto que eu vou providenciar aos widgets que sim o pretenderem, neste caso é um characters repository.

Vamos só ver se isto funciona. Ok, continua a funcionar agora com o provider, está mais organizado.

Vamos então avançar para a parte da API. Para começar temos que ver onde é que nós vamos buscar estes personagens, a que servidor é que nós vamos buscar isto. Existe uma API para isso. Portanto se forem aqui a este endereço de one-api.dev, eh documentation, vão ver aqui a documentação para aceder a esta API. E em particular vão ver aqui que existem vários endpoints disponíveis para obter informação. Todos eles começam com este endereço e depois acrescentam à frente qual a operação, qual a entidade que querem obter. Podem ter os livros, os filmes, e na realidade o que eu quero é obter este, ou seja, a lista de personagens que constituem o Lord of the Rings.

É uma boa prática antes de começarmos já a programar, fazemos alguns testes com esta API. Nós próprios fazemos umas chamadas API para vermos se entendemos o que é que ela está a fazer. Existem várias ferramentas para fazer, nomeadamente há uma muito conhecida que é o Postman. Mas o IntelliJ traz uma forma - o IntelliJ a versão Ultimate apenas, essa versão mas que é acessível a todos os estudantes - traz também uma forma de fazer pedidos APIs. No caso do Android Studio infelizmente não traz essa funcionalidade, então podem instalar eventualmente um plugin. Eu vou instalar aqui um plugin chamado REST Console. Não é nada de especial, aviso já, mas dá para só para experimentar.

Então como é que nós vamos dar? Este plugin ele aparece aqui REST Console. Ele por acaso já aqui está gravado, já tinha gravado e o que eu tinha colocado cá antes. Mas basicamente se repararem aqui em cima colocam o endereço que querem chamar. Já tínhamos visto que tinha que se começar por v2 e depois era tinha que começar por este prefixo, digamos assim, depois de ter o character. E há aqui um pormenor importante que é este header que é preciso passar que tem a ver com isto aqui.

Ok, eu tenho que enviar este cabeçalho em todos os meus pedidos, sendo que isto aqui deve ser substituído por uma chave de API que vocês devem obter através de uma conta que devem criar aqui. Portanto eu criei uma conta, através dessa conta obtive a minha key e vou substituí-la aqui. E é isso que aparece aqui. Ok, aqui tenho a seguir a Bearer tenho a minha API key que me foi atribuída a mim. Vocês se quiserem experimentar isto devem obter a vossa própria API key aqui e colocar aqui.

Ok, uma vez feito isto eu posso agora fazer submit e passado a um bocado ele dá-me então o resultado da chamada à API. Ok, cá estão as personagens todas, estão num formato chamado JSON. Este formato é um formato muito conhecido. Ele começa por ter aqui um parâmetro docs que lá dentro tem uma lista - docs significa que é uma lista de entidades, neste caso personagens. Por exemplo, neste caso esta personagem tem o nome Adanel e é humano, é uma um feminino, etc. E vamos por aqui fora, por aqui fora temos imensas personagens. E no final até há uns atributos que dizem que na realidade há 933 personagens. Depois há aqui um limite, um offset não é usado neste caso. É com isto que a gente vai trabalhar para conseguir mostrar aqui estas mesmas personagens que aqui estão.

Primeira coisa que eu vou fazer é criar uma classe que me permite fazer pedidos HTTP. Os pedidos API, eu vou começar por criar aqui uma pasta http e um ficheiro http_client. Vamos ver o que é que está aqui a acontecer. Eu basicamente estou a usar este client que vem da biblioteca http, a tal que já pusemos no pubspec no início do vídeo. E é com esse client que eu vou trabalhar, mas mais tarde se quiser trocar isto para outra biblioteca é relativamente fácil de o fazer.

E depois tenho aqui então o método get. Eu também tenho um post, mas neste caso apenas vou precisar de gets que recebe dois parâmetros: o URL ao qual quero fazer o pedido e um conjunto de headers que quer passar ao pedido. Pois limito-me a delegar isso neste client. Tenho apenas que fazer aqui uma transformação: o URL vem em string e este client quer um URI, então tenho que fazer este URI.parse do URL. Mas de resto é relativamente linear.

No entanto ele está a sublinhar isto e eu deixei este erro de propósito. Vamos ver o que é que ele diz. Ele diz que estava à espera que esta função retornasse um Future<Response> e não um Response. Qual é a razão disto e o que é que é esta história dos futures?

A ideia aqui é que esta função ela vai poder demorar algum tempo, não é? Ir ao servidor pode demorar alguns segundos e nós não queremos prender a aplicação durante esse processo. Nomeadamente se tivermos a desenhar coisas no ecrã, não queremos parar de desenhar coisas no ecrã, não queremos parar de responder a eventos. Por isso esta função é aquilo que se designa uma função assíncrona. Quando a função é assíncrona significa que não fica bloqueada à espera que termine. Ela tem que retornar aquilo que se chama um Future.

O Future é um objeto que inicialmente está no estado incompleto, digamos assim, e depois eventualmente algures no tempo vai ficar no estado completo. Portanto nós recebemos um objeto que não tem logo o resultado que nós queremos. Ao transformarmos isto, vamos seguir a sugestão dele, ao transformar isto então num Future<Response>, o que isto diz é que este response vai estar encapsulado num objeto que inicialmente não vai ter lá a resposta mas que mais tarde, eventualmente passado alguns segundos, vai ter a resposta. Então é com isto que nós temos que trabalhar sempre que fizermos pedidos remotos: temos que trabalhar com futures.

Vamos agora começar a transformar o nosso characters repository para passar então a usar este http client e fazer os pedidos ao servidor. Eu vou deixar à mesmo este return para já por aqui porque vai dar jeito para nesta fase de testes, mas vou já criar aqui uma variável que vai ser o meu http client. E eu podia agora fazer aqui isto, mas mais uma vez não é boa ideia. Nós sabemos que é uma boa prática que fazer injeção de dependências em vez de estarmos a criar as dependências aqui. Eu não sei se mais tarde não vou querer alterar esta dependência conforme estou em teste ou não estou em testes.

Então o que nós vamos fazer é providenciar este http client através de injeção de dependências. No entanto não vamos poder fazer da forma que fizemos aqui. Lembrem que aqui nós obtivemos a dependência, por exemplo do characters repositório, através deste context.read. No entanto nós aqui não temos nenhum contexto para obter isso. Então esta é uma limitação da biblioteca que estamos a usar que é o provider, que apenas permite injetar dependências em widgets. Os widgets é quem tem aquela variável build context que obtêm através da função build. Como não temos essa ligação, vamos fazer isto old school, digamos assim, que é passar através do construtor.

Eu vou querer que isto seja named, ou seja, que isto seja um atributo com nome. E vou dizer que isto não é assim, é um HttpClient. E agora vou ter que fazer aqui para indicar que este client corresponde ao _client que é privado. Tenho que tirar também daqui isto. Pronto, desta forma respeitamos o princípio do encapsulamento: o client fica privado dentro do repositório, é passado através do construtor através do nome, ou seja, client: qualquer coisa, e eu atribuo o parâmetro que recebo ao atributo _client.

Feito isto eu tenho que alterar aqui já isto. Ok, portanto como é um parâmetro por nome eu tive que dizer client:, fica bastante também mais claro.

Agora vamos voltar aqui e agora o getCharacters tem que usar este client para fazer um get a um endereço, ou seja, ele recebe um URL e uns cabeçalhos. Ok, vamos começar pelo URL. Vamos buscá-lo aqui, ainda o temos aqui. Isto tem que começar por https://the-one-api.dev/v2/character. E agora preciso também dos headers que são um Map. Um Map em Dart é só fazer assim, em que a chave vai ser este Authorization e o valor vai ser o valor que ali está. Só aqui ir buscá-lo, tem que ser todo.

Neste momento nós estamos a chamar já o servidor mas não estamos a fazer nada com a resposta. Vamos guardar a resposta aqui num response. E agora temos aqui um problema que é: este response, este get é assíncrono, o que quer dizer que este response é um Future<Response>, não é um Response. Ou seja, eu não consigo agora chegar aqui, se eu fizer um print(response) ele não vai dar nada de jeito. Vamos ver isso em ação já. Dar um hot restart para voltar ao botão. E agora cá está o que ele escreve: é um instance de Future<Response>. Mas o que eu quero é poder obter mesmo a resposta propriamente dita.

Então nesta fase o que eu vou fazer é usar esta palavrinha await. Await significa vou esperar que a resposta, vou esperar que o future que ele me devolve esteja completo no fundo. E nessa altura, como o future já está completo, o que ele me vai devolver é, em vez de um Future<Response>, vai-me já devolver um Response. Isto significa que eu basicamente estou a bloquear a execução do meu programa neste ponto. Vou esperar que ele acabe de fazer o que tem a fazer para então escrever a resposta.

Há aqui só duas coisas que acontecem quando nós colocamos aqui este await. Sempre que nós colocarmos um await dentro de uma função, ele vai se queixar a dizer que a função tem que ser assíncrona. E para isso nós vamos acrescentar aqui este async. Mas ao acrescentar este async, a seguir ele queixa-se de outra coisa que é: as funções assíncronas têm que retornar um Future. E portanto eu tenho que converter isto para Future.

Pronto, agora se eu correr isto novamente... ah, agora ele queixa-se como isto é um Future, agora isto deixou de funcionar porquê? Porque ele está à espera de receber uma lista de characters e não um Future de uma lista de characters, que é o que ele está a receber neste momento.

Para nós resolvermos isto facilmente, vamos tirar isto de dentro do setState. Vamos colocar aqui fora, já vou explicar porquê, e vamos colocar aqui o famoso await. Sempre que vocês quiserem transformar um Future<qualquer coisa> nessa coisa, podem fazer um await, mas isso tem sempre um preço a pagar que é: a função na qual fazem isso tem que passar a ser async. Nunca se esqueçam disso.

Porque é que eu passei isto para fora para onPressed em vez de estar no setState? Porque o setState não pode ser assíncrono. Eu não posso... eu podia fazer isto aqui dentro mas isso quer-me dar um erro e portanto ele não deixa fazer isso aqui dentro do setState.

Vou colocar aqui onPressed vai ficar bloqueado à espera da resposta deste pedido ao servidor. Quando obtiver essa resposta vai obter uma lista de characters e nessa altura o que é que a gente faz no setState? Nada, a gente pode simplesmente deixar um setState vazio para indicar que ele deve refrescar o ecrã agora que já tem um characters preenchido. A variável characters já está preenchida, ele deve refrescar, deve voltar a chamar o build. E quando o characters já está preenchido, ele se bem se lembram, ele tem aqui um characters.isNotEmpty que se já estiver preenchido ele vai chamar o buildList e portanto nesta altura vai preencher isto já com a lista de characters que nós pretendemos.

Agora resolvemos isto já podemos... Ok, e agora se fizermos get characters, reparem que agora ele já dá uma instância de Response. O que é que é esta instância? Esta instância é do tipo Response e em particular há duas coisas que nos interessam no Response. A primeira é o status code. O que é que é isto? O status code, se nós olharmos aqui para o REST Console, além desta resposta em JSON ele também retornou um 200 OK.

Portanto a primeira coisa que ele fez é ver se este código de erro que aqui está, ou melhor, se este código HTTP de resposta é o 200, que é o código universalmente definido para OK. Devemos começar por ver isso porque pode ter corrido mal e não termos recebido nada de jeito, temos recebido um erro, e portanto não vamos tentar processar o JSON que está associado a esse erro.

Então primeiro, primeira coisa que devemos fazer é um if: o status code é igual a 200, que é o OK, então é que vamos processar o JSON. Caso contrário vamos lançar para já uma exceção só indicando qual foi o status code que recebemos para percebermos o que é que está a acontecer. Em princípio não devíamos receber algo diferente de 200, por isso queremos que ele lance uma exceção para nos indicar que aconteceu alguma coisa imprevista.

Agora que sabemos que vem um OK, significa que então o response traz lá dentro um body que é uma string que contém isto, contém isto que aqui está. Nós agora queremos processar isto. Isto está como string mas nós queremos que isto seja num formato estruturado. Isto na realidade é como se fosse um Map que lá dentro tem chaves, por exemplo o docs que neste caso corresponde a uma lista de mais uma vez Maps que tem ID chave ID valor tal, chave height valor tal, chave race... Ok, estão a ver? Portanto um Map com uma lista de Maps, digamos assim, lá dentro.

Então vamos começar a trabalhar isto. Primeira coisa que temos que fazer é converter precisamente de string para uma coisa mais estruturada. Felizmente o Dart tem uma função chamada jsonDecode que faz precisamente isso. Pega numa string que tem JSON e retorna um formato mais estruturado.

E agora como isto está no formato estruturado, nós podemos fazer trabalhar nisto como se fosse um Map, ou seja, por exemplo podemos ir aqui buscar o docs. Só aqui voltar a mostrar... ok, e ele vai nos dar isto daqui para baixo, ou seja, vai nos dar uma lista de coisas. Para ver em ação vou já imprimir aqui o responseJson['docs'] só para verem o que é que está a acontecer.

Vamos então aqui... ok, estão a ver que o que ele está a dar é uma lista. Isto significa que é uma lista, este parênteses reto, depois lá dentro tem então estes atributos. O que quer dizer que eu agora posso guardar por exemplo isto numa lista e agora posso iterar essa lista e para cada elemento posso por exemplo escrever o seu nome. Para cada characterJson eu posso escrever o seu nome. Como é que eu sei qual é o atributo que tem o nome? Mais uma vez venho aqui ver e de facto há aqui um name. Então é aí que eu vou buscar.

Vamos correr isto novamente. Reparem que eu estou sempre a fazer hot restart porque eu quero que ele volte ao botão para que eu possa agora então fazer isto. E cá estão os nomes todos aqui que vieram do servidor.

O que é que agora quero fazer com isto? Eu já tenho uma classe Character, como podem ver aqui, e o que eu quero é que essa classe Character, em vez de estar com dados fixos, seja com os dados que vêm daqui. Ou seja, este id havia de ser o characterJson no atributo _id, este name será o characterJson no atributo name, etc., etc.

Para fazer isso eu vou criar aqui uma função aqui no Character que me permite criar um objeto destes a partir do JSON respetivo. Isto é uma boa prática. Normalmente quando se trabalha com APIs, normalmente a gente pega nos objetos do modelo e além de ter um construtor normal como temos aqui, temos uma outra forma de criar esse objeto diretamente a partir do JSON.

Como é que isto funciona? Tenho aqui esta função fromMap, ela recebe um Map que é basicamente o que vem do JSON e a seguir retorna um objeto baseado nos atributos que vêm de lá. Podemos ver aqui que _id corresponde ao _id, temos o birth, temos o death e por aí fora.

Com base nesta função nós podemos agora facilmente aqui fazer isto, que é podemos criar aqui um... ok, e assim obtemos um Character. Mas o que eu quero é obter uma lista de characters. O que eu podia fazer agora era criar uma lista vazia, ir adicionando à medida que percorri o ciclo um a um os characters, trazer essa lista. Mas vamos fazer isto de uma forma melhor, vamos usar o map que já foi falado num vídeo sobre navegação em Flutter que eu já coloquei, para basicamente transformar objetos desta lista do tipo JSON, vamos chamar-lhe assim, em objetos do tipo Character.

Pegar nesta lista, fazer um map - ou seja, o map significa transformar - e o que eu tenho aqui é o characterJson. Eu até vou copiar daqui que é para vocês verem as semelhanças. E o que eu quero fazer é pegar nesse e transformá-lo no Character. Então basicamente o que isto está a fazer é pegar nesta lista de characterJson e transformar numa outra lista em que cada Character de JSON é transformado no respetivo Character usando esta função. Além disso eu tenho que converter isto para uma lista.

Agora já posso colocar isto numa lista characters. Isto pode ser eliminado e basicamente o que eu vou fazer é retornar estes characters. Ah, ele tem... eu aqui tenho que dizer que isto é um List<Character> porque senão depois ele aqui não sabe que estou a retornar um Future de um List<Character>.

Reparem que há aqui uma coisa interessante nas funções assíncronas que é: nós estamos a retornar um objeto do tipo List<Character> mas o tipo de retorno que aqui está é Future<List<Character>>. Ou seja, ele automaticamente percebe como é uma função assíncrona que o que a gente quer retornar na realidade é um Future deste tipo que aqui é retornado.

Como é que isto funciona? Quando alguém chamar esta função, este Future vai começar por estar não preenchido, incompleto se quiserem, enquanto esta função não termina. E depois mal ela termine com este return, o Future passa a estar preenchido com esta lista de characters. Cá está, graças a este await nós vamos bloquear aqui e só quando isto terminar é que nós vamos obter uma lista de characters para então mostrar no ecrã.

Então vamos ver isto a funcionar. Cá está, demorou um bocadinho mas temos então aqui os nossos personagens todos obtidos a partir daquele JSON.

Esta abordagem parece funcionar bem mas tem alguns problemas. Em particular, quando carregamos no botão devíamos ter feedback, por exemplo uma rodinha a rodar ou uma indicação loading a dizer que está um processamento em curso. Não parece, carregamos no botão e não aconteceu nada. Se aquilo demorar alguns segundos o utilizador vai ficar perdido.

O outro problema tem a ver com o ponto onde nós chamamos a API. Neste momento estamos a chamar em reação a um evento, ou seja, dentro de uma função onPressed que pode ser tornada assíncrona. Mas por vezes nós queremos que seja no momento em que abrimos um novo ecrã que seja feita a chamada assíncrona. Ora o build, a construção do ecrã, tem que ser feito de forma síncrona, então isso vai criar aqui problemas acrescidos.

Fiquem para o próximo vídeo para ver como vamos resolver estes dois problemas. 