# Consumir uma API em Flutter LOTR - Parte 3

Neste vídeo vamos continuar a desenvolver a aplicação do Lord of the Rings. Já tínhamos implementado este botão quando se carrega aqui vai ao servidor buscar através de uma API buscar uma lista de personagens do Senhor dos Anéis. Reparem, eu vou simular agora que o servidor está lento, carrego aqui, nada acontece, fico na dúvida... Oi, finalmente apareceu! OK, se isto demorasse mais tempo ainda era mais estranho, mais provável era o carregar várias vezes naquele botão e fazer vários pedidos ao servidor desnecessariamente.

Este é um dos problemas que queremos resolver. O outro é que ainda não está a funcionar o detalhe, tá sempre vai aparecer Pedro e agora quero que apareça a personagem respectiva. A razão para isso estar a acontecer é porque o repositório já está implementado para o get characters que obtém a lista dos personagens, mas ainda não está implementado para o get Character. Neste momento ainda está fixo.

Então nós vamos fazer uma coisa parecida com esta, vamos chamar API para obter os dados de um certo personagem e retornar os e retornar um objeto com essa informação. Vamos lembrar-nos daqui da API e reparar que existe de facto aqui, nós estávamos a usar este barra Character, mas se à frente do barra Character lhe passarmos aqui um ID, ele na realidade vai obter especificamente os dados deste personagem com este ID.

Dito isto, vamos começar por copiar esta parte para aqui e aqui em vez de... vamos deixar este, mas vamos colocar aqui o ID à frente. Este ID é o ID que ele recebe aqui por parâmetro, portanto se eu quero obter o com o certo ID eu chamo API com esse ID. Agora vou à mesma verificar, tenho a mesma que verificar se o status code é 200 ou é um erro, só que aqui dentro a informação vai ser diferente.

Vamos só perceber que informação é essa aqui no rest console. OK, eu já coloquei aqui um exemplo de um ID. Isto é o exemplo de um ID de um personagem, portanto se eu fizer submit disto eu tenho esta resposta, ou seja, obtenho apenas... é muito parecida com a outra, existe o mesmo um DOC com uma lista, eh, mas dentro da lista aparece apenas os dados do personagem que me interessa.

Então como isto é muito parecido, podemos aproveitar a maior parte do código já existe. Vamos ter à mesma um characters JSON, só que agora dentro deste characters JSON vai estar apenas um único objeto e portanto podemos obtê-lo diretamente. Podemos criar aqui uma variável que vai ter o único personagem que está lá dentro, Character JSON, que é simplesmente o characters JSON na posição zero. E agora é só retornar diretamente o Character from map desse Character JSON. Lembro que o que isto faz é construir um objeto Character a partir do JSON que foi obtido do servidor.

OK, já sabemos que este await para estar sublinhado é porque falta aqui um async e também já sabemos que quando colocamos a função async ela tem que retornar um Future. Vamos retirar daqui este ponto de interrogação, assumir que o está sempre preenchido.

E a partir deste momento, ao alterarmos isto, o nosso Character Detail Page deixou de funcionar. Porquê? Porque o que eu faço aqui é obter o get Character de forma síncrona, estou à espera de obter de forma síncrona, mas isto agora é assíncrono e portanto este Character é um Future Character, mas aquilo que eu quero aqui é mesmo o Character. Quero poder obter o name do Character, o birth do Character e o death do Character.

Se fôssemos usar a mesma técnica que usamos no último vídeo, a forma de eu converter um Future em algo que não é um Future é um await, ou seja, bloquear esta chamada de forma a que ele fica aqui à espera que ele dê um get Character quando finalmente estiver pronto. Então devolve já o Character, agora já devolve o mesmo e não o Future Character. O problema é que para isto ter aqui um await, o build tinha que ser async. E isso não é possível.

Então como é que vamos resolver isto? Vou agora mostrar aqui com os slides para percebermos melhor o que está a acontecer. Basicamente eu quero quando carrega aqui numa opção chamar o Character detail page, por sua vez vai chamar o build para construir esta página com base no ID que está associado a este item que aqui está, e ele há de ir ao servidor e fazer isso. O problema é que o ir ao servidor, que é este repositório get Character, demora algum tempo.

Portanto se eu escolher aqui este Aragorn, o ID dele é este que aqui está, que é este, e vou chamar esta função, mas esta função agora demora alguns segundos porque tá a ir ao servidor. E como tal eu não posso parar o build, ele tem que mostrar imediatamente alguma coisa. Quando eu carrego aqui ele tem que mostrar logo um ecrã muito rapidamente, não pode dar-se ao luxo de ficar à espera do servidor.

E portanto uma das hipóteses que nós temos é começar por criar uma variável Character que é o nosso carácter, né, o nosso personagem aliás, que começa a por estar a nulo. E depois em paralelo, de forma assíncrona, eu chamo repositório get Character e deixo-o a trabalhar. Mas reparem que eu não... ele não bloqueia. Como eu digo que estou aqui a dizer de forma assíncrona significa que ele não está a bloquear a construção da página. Portanto eu faço o igual a nulo e chamo logo o build com o igual a nulo.

Claro que como eu não tenho os dados do personagem, eu vou ter uma coisa deste género: não aparece o nome dele, aparece-me aqui este "Born nulo", "Death nulo", horrível. OK, mas eventualmente esta função vai terminar, a chamada o servidor há de responder com alguma resposta, passo a redundância, e nessa altura eu posso preencher esta variável. O Character pode passar a ter o valor que veio do servidor quando chegar a resposta.

Uma vez que eu tenha esta variável preenchida, eu posso voltar a chamar o build para ele refrescar o ecrã e agora já vai funcionar corretamente. Então a primeira coisa que eu tenho que fazer é ter uma variável Character nesta neste widget. E a partir do momento em que eu tenho uma variável, significa que o widget passa a ter estado. Se o widget passa a ter estado, eu tenho que passar a stateful. Logo vou converter isto para stateful widget.

Agora vou criar então aqui uma variável Character ponto interrogação para poder ser nulo. E aqui o que eu vou fazer é este Character vai passar a ser Future Character. E isto ainda não me dá nada, mas eu quero agora perceber como é que eu obtenho a partir de um Future, como é que eu sei quando é que ele terminou, como é que eu sei que este Future já tem dados lá dentro.

Deixa voltar aqui aos slides. Portanto o que eu agora quero perceber é como é que eu sei que isto aconteceu, como é que eu sei que chegou a resposta. Bem, vamos só voltar aqui um bocadinho atrás. Eu já falei sobre isto, mas não é demais recordar: um Future é um objeto que pode ter dois estados, ou está em curso ou está completo, sendo que caso esteja completo pode ter tido sucesso ou pode ter dado um erro.

Quando eu chamo esta função, ela no início vai estar em curso e eventualmente, passado algum tempo, vai estar completo. Já tínhamos visto que uma das formas que eu tenho de saber quando é que ela está completa é o await. Só quando esta função, este Future, passar para o estado completo é que ele sai deste await com o Character pretendido. Isto tem o problema que bloqueia a execução.

Então qual é a solução para isto? O Future tem uma função chamada then. Esta função then pode ser aplicada a qualquer Future. OK, lembro que isto retorna um Future, tá aqui Future, e portanto eu posso chamar isto ponto then. E o que é que o then tem lá dentro? Uma função que é chamada um lambda que é chamado quando a função termina, e o lambda inclusivamente dá-me logo qual é o Character que ele obteve. Mesmo o Character, já não é o Future, é mesmo o Character.

O que é que eu posso fazer nessa altura? Atribuir esse Character à minha variável que estava lá em cima a nulo e que agora passou a não estar a nulo. Vamos então fazer esse processo aqui. Portanto Future Character then... OK, ele faz-me logo isto. Eu vou substituir este value por Character para se perceber que o que ele obtém é um Character. Vou transformar isto num bloco para ficar mais claro. E o que eu quero fazer aqui dentro é basicamente Character igual a Character.

Agora isto não é suficiente. Para os que estão mais atentos e se lembram disto: eu quando quero refrescar o ecrã, quando eu altero o estado de um widget de um stateful widget, eu tenho que chamar o setState para indicar que ele tem que repintar o ecrã, tem que voltar a chamar o build. E por isso eu vou colocar aqui um setState aqui dentro, e esta alteração de estado tem que ser feita aqui dentro do setState.

Falta-nos apenas corrigir estes três casos. Aqui esta variável não existe, agora chama-se underscore Character. Ele agora não gosta que nós tentamos aceder ao name de uma variável que pode estar a nulo, e de facto na primeira vez que ele vai fazer build ela vai estar a nulo. E como tal vamos usar aqui o safe operator e isso resolve o problema. Aqui, aqui mesmo assim não resolve, vamos ter que usar isto para dizer que caso ela esteja nulo então colocamos uma string vazia.

Agora antes de correr isto eu vou colocar aqui um debug print e já vamos perceber porque é que isto é importante. Fazer aqui um restart. Vamos então obter os Characters e faz conta, vou aqui a este... isto aparentemente funcionou bem, mas reparem o que que está a acontecer: ele está permanentemente a obter Character do servidor para não massacrar.

E vamos perceber aqui que cada vez que eu chamo build... neste caso, a primeira vez eu build, oiço, ele começa a iniciar este processo de chamar o get de forma assíncrona. Isto há de ser eventualmente chamado mais tarde, não é logo chamado. Desenha inicialmente isto com o Character a nulo. Passado alguns segundos vem a resposta do servidor. Ao vir uma resposta do servidor, esta função é chamada. Esta função aqui é chamada e nomeadamente ele coloca o Character no Character, tudo bem, mas faz um setState.

Ao fazer um setState chama novamente o build. Ora, ao fazer novamente o build, o que é que ele vai fazer? Novamente um pedido ao servidor e anda por aqui fora. Claro que como o Character já tá preenchido, a gente não dá conta disto, a gente olha para o ecrã e parece que está tudo bem, mas na realidade ele está a massacrar o servidor desnecessariamente.

O que nós queríamos era que este código aqui fosse chamado apenas da primeira vez que nós entramos nesta página e que os builds subsequentes não voltassem a chamar isto. Para isso nós vamos usar aqui uma função que existe em todos os widgets stateful que é o initState. Fiz control O para fazer override ao initState. Primeira coisa que devemos fazer é chamar o super.initState e agora vamos simplesmente copiar isto tudo para ali. Não precisamos de alterar mais nada.

Isto em princípio vai ser corrido só uma vez. Para confirmarmos vamos correr isto novamente. Vamos então chamar o get characters e agora aqui... e pronto, fez um único "vou obter o Character do servidor", não fez mais nenhum. Claro que se eu agora voltar atrás e chamar outro, ele vai voltar a obter o Character do servidor. E agora já temos isto a funcionar corretamente sempre obter.

Repararam que temporariamente aparece ali os tais nulos, mas logo que tenha a resposta do servidor ele volta a fazer um build e refresca o ecrã com informação correta. Esta técnica funciona sempre que queremos um widget que depende de uma chamada a uma função assíncrona. O princípio é sempre o mesmo: o widget deve ser stateful, devemos ter uma variável que guarda aquilo que pretendemos mostrar no ecrã mas que inicialmente está nulo, e temos um initState que vai preencher essa variável no then de um Future, de uma função que retorna um Future, e que nessa altura também faz um setState.

Embora esta técnica funcione sempre, é um bocadinho chata de estar sempre a implementar. E como tal vamos aprender agora uma forma mais expedita, mais simples, de resolver o mesmo problema. Como podem ver, voltamos aqui ao estado inicial do nosso widget. Ele passou a ser novamente um stateless, não tem um initState, não tem um Character pode ser nulo, não tem um then, não tem nada daquelas técnicas que vimos antes, porque nós agora vamos usar outra coisa chamada FutureBuilder que permite de uma forma muito mais simples fazer tudo aquilo que fizemos até agora.

O FutureBuilder, para começar, é um widget, e por isso eu vou fazer um wrap daquilo que quero que seja refrescado com base no Future num FutureBuilder. Em vez de um child eu vou colocar um builder, e isto vai receber dois parâmetros: um é o contexto que nós não vamos precisar, outro é o snapshot que vai ser muito importante, eu já vou explicar porquê. Depois colocamos isto tudo aqui num return e para já o que temos é que o builder retorna sempre a mesma coisa, já lá vamos.

Mas além disso, o FutureBuilder recebe dois parâmetros essenciais além do builder: ele tem que receber um Future, e o Future é simplesmente uma chamada, uma função que retorna um Future ou um objeto do tipo Future. Neste caso é este, já sabemos que isto retorna um Future Character, e portanto nós vamos colocar isto aqui. E deixamos de chamar aqui, que era o grande problema que nós começamos por resolver.

Então como o que é que vai acontecer aqui? Este FutureBuilder quando é criado vai começar por chamar este Future, e depois este builder é chamado à medida que o snapshot vai mudando. O que que é isto? O snapshot... deixa mostrar-vos aqui novamente este diagrama. Se bem se lembram, o Future começa a por estar em curso e depois pode ficar completo, sendo que se ficar completo pode ser por ter tido sucesso ou por ter tido um erro.

O snapshot é uma variável que o FutureBuilder cria e que tem uma propriedade chamada connectionState que em particular pode estar waiting enquanto ele está em curso, ou done quando ele fica completo. Uma vez ficando completo, eu a seguir posso ir ao snapshot ponto data ver se ele tem dados, nesse caso correu bem, ou fazer um snapshot ponto error e ver se ele tem lá um error, nesse caso quer dizer que correu mal. Este data que aqui está é exatamente o objeto que nós queremos obter do servidor, neste caso vai ser o Character.

Dito isto, vamos então desenhar coisas diferentes consoante o que está no snapshot. Para começar vou fazer aqui um refactoring e vou extrair isto para um método chamado buildCharacter e vou lhe colocar aqui isto como parâmetro. E como é boa prática vou transformar isto num widget e nós aqui falta-nos aqui passar o Character, mas já lá vamos.

OK, vamos então ver os vários estados que o snapshot pode tomar. Primeira coisa é ver o connectionState dele que pode ser o waiting ou done, há outros tipos. Portanto o mais simples é nós verificarmos se ele for diferente de done, então vamos assumir que é como se fosse waiting, e portanto isto é o nosso waiting. Caso contrário entramos aqui em dois casos: se o snapshot tiver erros então mostra erro, else return buildCharacter, e neste caso é o snapshot ponto data.

Agora o que é que a gente pode fazer aqui no waiting? Em vez de colocarmos os nulos que era o que aparecia antes, vamos retornar um CircularProgressIndicator que é aquele widget da rodinha a rodar, aquele círculo a rodar enquanto está a pensar. E aqui podemos também retornar simplesmente um texto, um texto com uma mensagem de erro genérica.

Vamos aqui experimentar... parece que está tudo a funcionar. A gente não está a conseguir ver a rodinha, mas vamos simular a rodinha indo aqui ao repositório e aqui no início do getCharacter fazer aqui um delay, um Future ponto delay com uma duração por exemplo de 2 segundos. Vamos esperar 2 segundos e a seguir é que vamos ao servidor. Portanto isto vai impor 2 segundos em cima do que ele já demora a ir ao servidor.

E reparem que eu fiz save, ele automaticamente já se vê aqui em ação, cá está a rodinha! E se houver um erro por alguma razão ele também vai mostrar o erro, que era uma coisa que não tínhamos antes. Portanto é importante nestas chamadas assíncronas tratar sempre os três casos: o caso de sucesso, o caso enquanto está a pensar, e o caso de erro.

Já agora, como é que ele sabe, como é que o snapshot sabe que ocorreu um erro? É quando lançamos uma exceção no repositório. OK, portanto este lançar uma exceção vai originar que o snapshot vai considerar que tem um erro, e no erro vamos poder obter esta exceção que aqui está.

A mesma técnica ao CharactersListPage também passamos a usar um FutureBuilder, e cá está: o connectionState diferente de done, o hasError, e o outro com o data. Aqui o botão passou a ter um comportamento diferente. A primeira coisa que ele faz é dizer que o buttonPressed é true, e nesse caso ele usa isso para dizer se vai mostrar o buildGetCharactersButton ou se aplica o FutureBuilder.

Fazendo então um resumo, o que é que precisamos para que a aplicação passe a usar uma API externa? Devemos colocar para já no repositório as nossas funções que vão ao servidor. Elas devem ser assíncronas, devem retornar Futures por causa disso, e devemos tratar sempre o código, o status code que vem do servidor, verificar se vem 200 ou vem outro, e no caso de vir outro lançar uma Exception.

Devemos também implementar este método nos nossos modelos, este fromMap que permite transformar JSON num objeto desse modelo. Uma vez feito isso, a nível de interface gráfica devemos usar o FutureBuilder em que aqui chamamos os... no Future chamamos os métodos que estão no repositório, e neste parâmetro builder, através do snapshot, tratamos os três casos possíveis: ou mostramos uma CircularProgressIndicator caso ela esteja waiting, mostramos um erro caso haja um erro, ou então mostramos o ecrã propriamente dito partindo do snapshot ponto data, porque para chegar a este ponto é porque de certeza que existem dados no snapshot.

Para terminar, devem verificar se não estão a fazer chamadas desnecessárias ao servidor, demasiadas chamadas em vez de fazerem só uma. Se for esse o caso, ponderem passar a chamada às funções do repositório para dentro da função initState. 