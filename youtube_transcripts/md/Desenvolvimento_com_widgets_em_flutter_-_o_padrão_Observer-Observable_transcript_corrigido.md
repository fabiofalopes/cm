# Desenvolvimento com widgets em Flutter - o padrão Observer-Observable

Neste vídeo vou introduzir o padrão observer observable e com ele melhorar ainda mais o nosso controlador de ar-condicionado. Em particular, vou separar melhor a interface gráfica da lógica de negócio, já vamos ver como.

Note-se que a utilização deste padrão para esta aplicação específica que é muito simples talvez seja exagerada, e em condições normais eu não o faria. Mas desta forma estou a preparar a aplicação já para que no futuro ela possa, por exemplo, fazer pedidos a um servidor, aceder a uma base de dados, utilizar sensores - tudo operações que demoram algum tempo e que vão beneficiar bastante deste padrão.

Vou então começar por explicar o que é afinal o padrão observer observable. Como o nome indica, existe um objeto observer e um objeto observable. O observable é o objeto que é observado e que tem um conjunto de variáveis - vamos chamar-lhe o estado desse objeto - e que há um conjunto de observadores que estão interessados em mudanças desse estado. Cada vez que esse estado muda, elas querem ser avisadas, querem perceber isso.

Para isso, elas têm que começar - estes objetos têm que começar por se registar como observadores do observable. E depois, de cada vez que há uma variável que muda, o observable tem que chamar este notify observers para basicamente notificar todos os observadores - podem ser vários - de que o estado mudou. Note-se que o observer regista-se uma vez como observador, mas depois o estado vai mudando várias vezes. Ok, isto repete-se de cada vez que a variável muda.

Algumas vantagens deste padrão: o primeiro é que nós podemos ter vários objetos a observar o mesmo observable. Isto pode ser interessante, mas a principal vantagem - que é que eu quero, a razão pela qual eu quero usar neste vídeo - é que isto permite uma separação clara de responsabilidades. Porque o observable, o objeto que é observado, não faz ideia o que é que os observers vão fazer com isso. Ele apenas, cada vez que muda uma variável, notifica, e depois cada observer faz o que entender.

Vamos agora ver como é que isso é aplicado em Flutter especificamente. Portanto, este padrão em Flutter usa classes ligeiramente - nomes ligeiramente diferentes do observer observable, mas o princípio é o mesmo. Em vez de observer é um consumer, e em vez de observable é um change notifier. E aqui, em vez de notify observers, é notify listeners. De resto, o princípio é o mesmo.

Então temos um controlador AC que é o nosso change notifier, é o nosso observable, e que tem uma variável temperatura que nós queremos que seja notificada de cada vez que há uma alteração. Queremos notificar os consumers - neste caso, os observadores deste controlador AC. Neste caso, quem é que é o nosso consumer? É o controlador AC page, a interface gráfica, digamos assim.

Então o consumer vai-se começar por registar como observador usando esta instrução: context.watch<ControladorAC>(). Não sei se se lembram, no vídeo anterior tínhamos feito um context.read<ControladorAC>() para fazer uma injeção de dependência, ou seja, para obter uma ligação ao controlador AC. Agora nós vamos mais longe e não só obtemos uma ligação ao controlador AC como observamos - ficamos a observar esse controlador. De cada vez que a temperatura mudar, nós vamos ser avisados.

O que é que significa nós sermos avisados? Neste caso, como o nosso objetivo é que a interface gráfica reflita a alteração do estado, nós simplesmente - esta mudança de estado implica chamar um build deste objeto, ou seja, deste widget. Neste caso, estamos a falar do widget. O que quer dizer que este widget, ou qualquer widget que seja um consumer, ele vai ser refeito, vai ser desenhado de cada vez que o estado mudar do objeto que ele basicamente está a observar.

Vamos então implementar este padrão. O nosso controlador AC vai ser o observável, e o controlador AC page vai ser o observador.

Então vamos começar aqui pelo controlador AC. Para ele ser observável, ou seja, para ele ser um change notifier em Flutter, basta pôr aqui extends ChangeNotifier. E depois não podemos esquecer de cada vez que mudamos o estado de chamar o notify listeners. Portanto, quando a temperatura aumenta: notify listeners. Quando a temperatura diminui: notify listeners. Basta isto. Está feito, o nosso controlador AC passou a ser observável.

No entanto, isto não é suficiente. Agora temos que deste lado garantir que o nosso controlador AC page está a observar este objeto. Primeira coisa que vamos fazer é vamos mudar aqui este Provider para ChangeNotifierProvider, porque o Provider normal não está preparado para que o objeto que a gente retorna aqui seja um change notifier. Quando este objeto que a gente retorna é um change notifier, nós temos que mudar isto para ChangeNotifierProvider.

Feito isto, o que é que a gente tem que fazer a nível do controlador AC page? Nomeadamente aqui no build. Nós antes estávamos a obter através de um read o controlador AC, e nós vamos passar a fazer watch. Só isto. Ao fazer o watch significa que passamos - não só obtemos o controlador AC como passamos a observar todas as alterações feitas ao controlador AC. Ou seja, de cada vez que ele mudar, este build vai ser chamado.

Como este build vai ser chamado, há aqui uma alteração, uma simplificação que podemos fazer, que é: nós aqui, se bem se lembram, este controlador.diminui(), controlador.aumenta() - nós temos que colocar, ou tínhamos que o colocar dentro de um setState para indicar que a interface gráfica tinha que ser refrescada após nós chamarmos este método. No entanto, agora que a nossa interface, o nosso widget, está à escuta de alterações ao controlador AC, isso deixa de ser necessário, porque ele vai ser automaticamente refrescado de cada vez que o estado muda do controlador AC. Portanto, podemos simplesmente tirar isto tudo, e mesmo assim ele vai funcionar.

Para termos a certeza que isto funciona, eu até vou arrancar novamente a aplicação e reparem como tudo continua a funcionar apesar de eu ter tirado o setState.

Só relembrando o que é que está aqui a acontecer e o que é que mudou: cada vez que nós carregamos neste mais, nós chamamos o controlador.AC.aumenta(). Quando chamamos o controlador.AC.aumenta(), ele não só aumenta a temperatura como notifica todos os observadores disso. Quem são os observadores? Basicamente, neste caso, é o controlador AC page que logo a seguir - o build começou por dizer que estava watch, estava à escuta de alterações ao controlador AC. Ou seja, aquele notify listeners o que vai fazer é chamar novamente este build, e ao chamar novamente este build, a temperatura já vai estar atualizada e, como tal, eu não tenho que fazer aquele setState.

Notem que ao retirar o setState, não só simplifiquei o código como aumentei a separação, a divisão entre interface gráfica e a lógica de negócio. Não é muito correto que a interface gráfica tenha não só que se preocupar em chamar o diminui, o aumenta, como tenha que perceber que isso poderá ter um efeito na sua própria interface. Até porque às vezes não tem - se a temperatura chegar aos 40º, o facto de eu chamar o aumenta não implica refrescar o ecrã. Mas se eu tiver lá um setState, eu vou estar sempre a refrescar o ecrã. Neste momento, o listener apenas é chamado se realmente houver um aumento da temperatura.

Para compreendermos melhor o padrão observer observable, podemos melhorar os testes unitários. Para quem não se lembra, os testes unitários são testes que testam apenas uma classe isolada da interface gráfica, não precisam de emulador. E vamos, por exemplo, pegar aqui neste teste e alterá-lo para que ele tire partido do facto de que agora o controlador AC é observável.

Para isso, nós vamos registar-nos como observadores deste controlador AC. E como é que fazemos isso? E agora reparem que há aqui um bloco de código que vai ser chamado quando o controlador mudar. Este bloco de código está - é observador daquele. Vamos começar por aqui um print apenas a dizer "o controlador mudou". Vamos ver o que acontece. Vou aqui mais uns - primeiro aqui um print "como observador" e aqui um print "aumentei a temperatura". Vamos correr este teste e ver o que acontece.

"Registei como observador", "aumentei a temperatura", "o controlador mudou". Note-se que isto era o que era suposto, ou seja, após aumentar a temperatura é que nós recebemos uma notificação a dizer que o controlador mudou. No entanto, isto pode parecer confuso porque, olhando aqui para a ordem dos prints, parece que ele iria escrever "como observador", "controlador mudou" e "aumentei a temperatura". Lembrem-se que este bloco de código só é chamado após eu invocar o aumenta() e ele notificar os listeners de que o controlador mudou. Portanto, não se baralhem com a introdução.

Podemos melhorar então o nosso teste para que este expect da temperatura do 21 seja feito após ser notificado. Ou seja, vou tirá-lo daqui, vou colocá-lo aqui. Quando eu aumentar a temperatura, eu vou notificar os listeners, e neste caso este listener vai apanhar essa notificação e vai verificar se a temperatura passou a ser 21. Vou tirar daqui os prints porque não devemos ter estes prints nos nossos testes, e vou correr novamente... e passou o teste. 