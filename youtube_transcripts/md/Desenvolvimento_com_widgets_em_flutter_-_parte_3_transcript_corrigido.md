# Desenvolvimento com widgets em Flutter - parte 3

Ok, temos então a nossa aplicação do controlador a mudar a temperatura muito bem, mas a hora continua estática. Portanto, vamos neste vídeo perceber como é que podemos modificar este widget de forma a que vamos mostrando a hora atualizada dinamicamente.

Vamos começar por mudar isto para passar a ser a hora real em vez de ser uma hora hard coded. Para isso, eu vou começar por fazer uma coisa que já tinha feito para os botões, que é extrair isto para um método que vou chamar `buildHoraAtualWidget`. OK, e ele criou aqui esta função. Vamos convertê-la, como fizemos também no outro, para uma função de bloco só para ficar mais simples de entender e porque vamos precisar de código aqui antes. E vamos alterar o retorno para Widget. Já tinha explicado no outro vídeo que isto é uma boa prática - estes builds todos que a gente vai criando aqui para nos ajudar a construir o ecrã devem todos retornar Widget.

Ok, então o que nós queremos é que isto deixe de ser fixo. Então vamos criar aqui uma variável `now` que vai ser o `DateTime.now()`. Ok, e isto é só para facilitar porque agora vamos... eh, tínhamos duas hipóteses: nós podíamos formatar este `now` com este formato, mas isto obrigava-nos a instalar aqui um package que não vale a pena complicar agora. E portanto vamos para uma solução mais simples, que é basicamente construirmos isto à mão desta forma: `${now.hour}:${now.minute}:${now.second}`. Isto vai dar o mesmo efeito e pronto.

Cá está, temos aqui a hora atual. Neste momento é 12:45 enquanto estou a gravar este vídeo. Se eu aqui fizer hot reload, ele vai atualizando. Ok, falta-lhe ali aquilo, podemos fazer ali um `padLeft`, mas não vale a pena só agora para mostrar o efeito. Pronto, isto mostra a hora atual, mas apenas quando redesenha o ecrã. E o problema é que enquanto nós não fizermos o `setState`, lá está, ele não vai redesenhar o ecrã. Já sabemos isso do vídeo anterior.

Aliás, uma coisa engraçada é que se ele fizer aqui um menos, como o menos me vai fazer atualizar o ecrã, redesenhar o ecrã, ele vai mudar a hora. Vai não só mudar a temperatura como mudar a hora para a hora atual, e aqui também muda a hora. Estão a ver? Pronto, mas o que eu queria era que isto mudasse automaticamente a cada segundo, não é, para dar aquele efeito engraçado.

Então como é que nós podemos fazer isso? Bem, basicamente, voltando aqui, nós vamos ter que ter aqui um processo que a cada segundo manda redesenhar o ecrã. Como é que vamos fazer isto? Vamos usar uma classe `Timer` do Dart para o fazer. Vamos colocar aqui por baixo da temperatura. Vamos criar aqui um `Timer?` e agora vamos fazer uma coisa que é: vamos inicializar o timer numa função especial que vimos nos vídeos anteriores, que é o `initState`.

Portanto, vamos fazer `@override initState()`. Vamos começar por chamar o `super.initState()` e agora vamos aproveitar para iniciar aquele timer, porque este `initState` só é chamado uma vez no momento em que é criado e adicionado ao ecrã, enquanto que o `build` vai ser chamado várias vezes. Este é chamado uma única vez e portanto é um ótimo sítio para nós inicializarmos o nosso timer.

Ok, então o nosso timer vai ficar assim: `timer = Timer.periodic(Duration(seconds: 1), (timer) { ... })`. E aqui vai ser... vai estar um bocado de código que vai ser chamado de segundo a segundo. É o que isto faz. Portanto, este timer... falta-me importar... o código que eu colocar aqui vai ser chamado a cada um segundo. E para testarmos isso, vamos já criar aqui um `debugPrint("acordei")` assim.

Uma coisa importante quando usarem o timer é garantir que ele não fica permanentemente ativo. Por exemplo, se vamos desligar a aplicação ou sair da aplicação, então podemos também fazer override a um outro método que é o `dispose`, onde devemos cancelar o timer antes de fazer o dispose. Ok, podemos fazer assim desta forma: `timer?.cancel()`.

Então vamos testar isto. Cá está, ele está a acordar de segundo a segundo. Portanto, temos neste momento uma forma de executar uma função qualquer, um bocado de código qualquer, a cada um segundo.

Ora, o que é que a gente quer executar ali? Basicamente, queremos que isto refresque o ecrã, redesenhe o ecrã. E já tínhamos visto o que é que é necessário para redesenhar o ecrã: é chamar o `setState`. Portanto, vamos chamar o `setState`, mas não vamos colocar aqui nada porque... nós na realidade não queremos modificar o estado da aplicação. Não há nada para mudar. Nós não temos nenhuma variável... se nós guardássemos o tempo atual numa variável, que me parece um bocado... e não é muito útil... ah, eventualmente podíamos aqui atualizar essa variável. Mas neste caso não vamos precisar de mudar nada no estado. Queremos apenas garantir que ele vai refrescar o ecrã, e portanto deixamos isto assim vazio, que será em princípio o suficiente.

Vamos fazer o teste. Tem que reiniciar... e cá está, ele redesenha o ecrã. E podes ver aqui também a cada um segundo, e como de cada vez que redesenha vai buscar novamente a hora atual, então isto está permanentemente atualizado.

Ok, qual é o problema disto? Esta solução não é espetacular porque nós basicamente temos aqui dois problemas. Um é que o nosso controlador tem aqui um timer que apenas é usado por um dos seus widgets. Imaginem que isto tinha aqui... eh, vários widgets aqui envolvidos. Isto era um dashboard para controlar uma casa inteligente e um dos widgets mostra a hora atual. Ora, para que é que temos que estar aqui a manter um timer no controlador quando apenas um dos widgets precisa do timer?

Mas o problema principal não é esse. O problema tem a ver com que este `setState` está a afetar o controlador state, que por sua vez afeta a página toda do controlador. Ou seja, ele manda redesenhar todos os widgets que aqui estão dentro. Ora, eu apenas preciso redesenhar este. Não faz sentido voltar a redesenhar este, nem este, nem este, nem outros widgets que aqui estejam. Por acaso, estes widgets são relativamente rápidos de refrescar, mas imagina que havia aqui um widget que era um gráfico que ia desenhar o gráfico a partir dos dados que vinha do servidor. Então é um bocado chato de segundo a segundo estar a redesenhar o gráfico e ir ao servidor outra vez para ir buscar os dados.

Então eu quero isolar o refrescamento desta hora apenas neste widget. Isto é um problema muito comum nas arquiteturas por widgets, que é: nós queremos isolar apenas os widgets que devem ser refrescados em cada momento para evitar uma perda de performance, de desempenho da aplicação.

Então como é que vamos fazer isso? Vamos aqui ao nosso `buildHoraAtualWidget`. Vamos fazer um refactor e vamos extrair um Flutter widget. Agora finalmente vamos extrair... até agora temos estado a extrair apenas métodos, mas está na altura de colocar isto no seu próprio widget. Porque reparem: o que eu pretendo agora é fazer isto - em vez de todo este widget que é o controlador ser redesenhado aquele assunto, apenas este widget vai ser redesenhado. Mas para eu apenas redesenhar, eu tenho que o isolar. Tem que extrair para criar o meu próprio widget.

Ok, então vamos então extrair aqui um widget e vamos chamar `HoraAtual`. Na própria... no próprio ficheiro. Podíamos passar isto para outro ficheiro, agora para simplificar vou manter aqui neste ficheiro.

E agora o que é que eu quero fazer? Primeiro, uma vez que este widget vai passar a ser ele a controlar o seu próprio estado e o seu próprio refrescamento - ele na realidade não vai ter estado, mas é ele que se auto-refresca - para eu conseguir fazer isso, para eu conseguir chamar o `setState` dentro dele, ele tem que passar a `StatefulWidget`. Portanto, nós vamos converter isto para `StatefulWidget`. Já tínhamos visto antes como é que isso se podia fazer.

O segundo passo é ir buscar este código que eu tinha aqui para o controlador e passá-lo... tirar daqui e passar para dentro do que acabei de criar. Porque todos... todos os widgets, todos os states têm estas funções `initState`, `dispose`, só que agora isto é apenas chamado quando aquele widget específico, este widget específico, é inicializado. Isto é apenas chamado quando esse widget deixa de ser necessário. E isto é apenas chamado quando eu vou desenhar este widget específico e não afeta os outros. Portanto, eu basicamente tornei este comportamento independente dos outros.

Para testarmos isso, ah, vamos aqui só fazer aqui um `debugPrint` a dizer "vou desenhar a hora atual". Portanto, já temos um debug print a dizer "vou desenhar o ecrã" a cada segundo, e agora "vou desenhar a hora atual", e vamos ver o que é que vai acontecer.

Ok, estão a ver? Isto continua a funcionar lindamente. Mas agora eu já só estou a chamar "eu vou desenhar a hora atual". Deixei de desenhar "vou desenhar o ecrã". O que quer dizer que este "temperatura 25" não está a ser redesenhado, o menos, o mais não estão a ser redesenhados, e outros widgets antes que eu quisesse colocar aqui à volta - ou tal gráfico, etc. - não seriam redesenhados.

Desta forma consegui isolar este widget. Ele tem o seu próprio estado - neste caso não tem estado, mas podia ter lá estar variáveis, etc., que ele próprio controlava - e portanto esta deve ser a forma correta de desenhar este tipo de widget: externalizando-os para que não afetem os outros widgets. 